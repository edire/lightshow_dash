üîê Authentication Requirements
Use Google OAuth 2.0 Authorization Code Flow (standard server-side flow).
Users authenticate once with Google.
After Google returns an authorization code:
  ‚Ä¢ Backend exchanges the code for Google tokens
  ‚Ä¢ Backend verifies the ID token and extracts the user's email
  ‚Ä¢ Only allow access if the email is in a configurable allowlist
  ‚Ä¢ Backend stores Google refresh token (optional, for future Google API calls)




üîë Tokens


Access Token (JWT)
  ‚Ä¢ Generated by the backend
  ‚Ä¢ Contains minimal claims: sub (email), name, exp
  ‚Ä¢ Expiration: 15 minutes
  ‚Ä¢ Signed using HS256
  ‚Ä¢ Stored in React state (in-memory) - NEVER localStorage
  ‚Ä¢ Sent via Authorization: Bearer <token> header
  ‚Ä¢ Lost on page refresh (triggers automatic refresh flow)




Refresh Token
  ‚Ä¢ Long-lived: 60 days
  ‚Ä¢ Stored ONLY in HttpOnly, Secure, SameSite=Lax cookie
  ‚Ä¢ NEVER exposed to JavaScript
  ‚Ä¢ Stored in database with:
    - user_email
    - token_hash (hashed)
    - expires_at
    - created_at
    - last_used_at
  ‚Ä¢ One-time use: Each refresh invalidates old token and issues new one
  ‚Ä¢ Rotation required: /auth/refresh endpoint issues:
    - New access token (15 min)
    - New refresh token (replaces old cookie)
    - Old refresh token invalidated immediately




üç™ Cookie Requirements
  ‚Ä¢ HttpOnly: Prevents JavaScript access
  ‚Ä¢ Secure: HTTPS only
  ‚Ä¢ SameSite=Lax: CSRF protection for most cases
  ‚Ä¢ Cookie name: refresh_token
  ‚Ä¢ Expiration: 60 days
  ‚Ä¢ Path: /api/auth (restrict to auth endpoints only)




üåê Frontend Requirements


Initial Load:
  1. Check if access token exists in memory (if yes, use it)
  2. If no access token, call POST /auth/refresh
     - If success (200): Store new access token in memory
     - If failure (401): Redirect to /login
  3. Once token obtained, call GET /auth/me to get user info


Axios Interceptor:
  ‚Ä¢ On 401 response from ANY request:
    1. Call POST /auth/refresh
    2. If success: Retry original request with new token
    3. If failure: Redirect to /login, clear state


Token Management:
  ‚Ä¢ Store access token in React state/context (in-memory)
  ‚Ä¢ Never use localStorage or sessionStorage
  ‚Ä¢ Token lost on page refresh is expected (auto-refresh handles it)




üß† Security Requirements
  ‚Ä¢ No localStorage for ANY tokens
  ‚Ä¢ Short-lived access tokens (15 min) limit XSS impact
  ‚Ä¢ HttpOnly cookie protects refresh token from XSS
  ‚Ä¢ SameSite=Lax provides CSRF protection
  ‚Ä¢ Refresh token rotation prevents replay attacks
  ‚Ä¢ Reuse detection: If rotated token is reused, invalidate entire session
  ‚Ä¢ Content Security Policy (CSP): no unsafe-inline




üèó System Structure


Backend Endpoints (FastAPI):


GET /auth/login-url
  ‚Ä¢ Returns: { "url": "https://accounts.google.com/o/oauth2/..." }


GET /auth/callback?code=...
  ‚Ä¢ Exchanges code for Google tokens
  ‚Ä¢ Verifies email against allowlist
  ‚Ä¢ Creates JWT access token
  ‚Ä¢ Generates refresh token, stores in database
  ‚Ä¢ Sets refresh_token HttpOnly cookie
  ‚Ä¢ Returns: { "access_token": "...", "user": {...} }


GET /auth/me
  ‚Ä¢ Requires: Bearer token
  ‚Ä¢ Returns: { "email": "...", "name": "..." }


POST /auth/refresh
  ‚Ä¢ Requires: refresh_token cookie
  ‚Ä¢ Validates refresh token from database
  ‚Ä¢ Invalidates old refresh token
  ‚Ä¢ Creates new access token
  ‚Ä¢ Creates new refresh token
  ‚Ä¢ Sets new refresh_token cookie
  ‚Ä¢ Returns: { "access_token": "..." }


POST /auth/logout
  ‚Ä¢ Invalidates refresh token in database
  ‚Ä¢ Clears refresh_token cookie
  ‚Ä¢ Returns: { "message": "Logged out" }


Database Schema:
  ‚Ä¢ Table: refresh_tokens
    - id (primary key)
    - user_email (indexed)
    - token_hash (hashed with bcrypt)
    - expires_at
    - created_at
    - last_used_at
    - revoked (boolean, for reuse detection)




üîÑ Flow Diagrams


Login Flow:
  1. User clicks "Sign in with Google"
  2. Frontend ‚Üí GET /auth/login-url
  3. Frontend redirects to Google OAuth URL
  4. User authenticates with Google
  5. Google redirects to /auth/callback?code=...
  6. Backend exchanges code, validates email
  7. Backend creates access + refresh tokens
  8. Backend sets HttpOnly cookie, returns access token
  9. Frontend stores access token in memory
  10. Frontend redirects to dashboard


Refresh Flow:
  1. Access token expires or page refresh
  2. Frontend ‚Üí POST /auth/refresh (sends cookie automatically)
  3. Backend validates refresh token from database
  4. Backend invalidates old token, creates new tokens
  5. Backend sets new cookie, returns new access token
  6. Frontend stores new access token in memory


Logout Flow:
  1. User clicks logout
  2. Frontend ‚Üí POST /auth/logout
  3. Backend invalidates refresh token in database
  4. Backend clears cookie
  5. Frontend clears in-memory token
  6. Frontend redirects to /login




üéØ Goals
  ‚Ä¢ User logs in ONCE and stays authenticated for 60 days
  ‚Ä¢ User can close browser and return without re-login
  ‚Ä¢ Dashboard stays open all day without re-auth
  ‚Ä¢ Access token auto-refreshes seamlessly
  ‚Ä¢ XSS cannot steal long-lived tokens
  ‚Ä¢ Refresh token reuse detected and blocked




‚ö†Ô∏è Implementation Notes
  ‚Ä¢ Allow multiple refresh tokens per user (multi-device support)
  ‚Ä¢ Cleanup expired tokens: Redis automatically handles this with TTL (setex)
  ‚Ä¢ Rate limiting on /auth/refresh: Max 10 requests per minute per IP
  ‚Ä¢ Reuse detection: If old refresh token used after rotation, revoke ALL user tokens




üö® Common Pitfalls & Solutions


Infinite Refresh Loop:
  PROBLEM: Frontend refreshes several times per second on login page
  CAUSE: Axios interceptor catches 401 from refresh endpoint and tries to refresh again

  SOLUTION 1: Exclude refresh endpoint from interceptor
    ```javascript
    // In axios interceptor
    if (originalRequest.url?.includes('/auth/refresh')) {
      return Promise.reject(error);  // Don't intercept refresh failures
    }
    ```

  SOLUTION 2: Skip auth check on login/callback pages
    ```javascript
    // In AuthContext initial load
    if (window.location.pathname.includes('/login') ||
        window.location.pathname.includes('/oauth-callback')) {
      setLoading(false);
      return;  // Don't try to refresh on these pages
    }
    ```

  SOLUTION 3: Prevent redirect loops
    ```javascript
    // Only redirect if not already on login page
    if (!window.location.pathname.includes('/login')) {
      window.location.href = '/login';
    }
    ```


Token Storage Key:
  PROBLEM: Can't look up refresh tokens in Redis using bcrypt hash
  CAUSE: bcrypt generates different hash each time, can't be used as lookup key

  SOLUTION: Use SHA256 for Redis key (fast, deterministic lookup)
    ```python
    import hashlib
    token_key = hashlib.sha256(refresh_token.encode()).hexdigest()
    redis.setex(f"refresh_token:{token_key}", ttl, data)
    ```
  Note: bcrypt is still useful if you need to verify without lookup (not our case)


CORS Issues with Cookies:
  PROBLEM: HttpOnly cookies not being sent with requests
  CAUSE: Missing CORS configuration

  SOLUTION: Backend must allow credentials
    ```python
    # FastAPI
    app.add_middleware(
        CORSMiddleware,
        allow_credentials=True,  # Required for cookies!
        allow_origins=["http://localhost", "https://yourdomain.com"]
    )
    ```

  Frontend must include credentials:
    ```javascript
    // Axios
    const api = axios.create({
      withCredentials: true  // Send cookies with every request
    });
    ```


Cookie Not Persisting:
  PROBLEM: Cookie doesn't survive browser close
  CAUSE: Cookie settings incorrect

  SOLUTION: Verify cookie settings
    ```python
    response.set_cookie(
        key="refresh_token",
        value=token,
        max_age=60*24*60*60,  # 60 days in SECONDS (not milliseconds!)
        secure=True,           # HTTPS only (disable in dev)
        httponly=True,         # JavaScript cannot access
        samesite="lax"         # CSRF protection
    )
    ```